# Day 14
## 멀티스레드
### 스레드
1. 작업에 대한 병렬처리 가능토록 함
2. 운영체제의 프로그램 처리하는 프로세스 단위
3. 프로그램의 멀티태스킹 -> 멀티 프로세스
4. 프로그램 내부의 멀티태스킹 -> 멀티 스레드
5. 스레드는 프로그램의 흐름(코드의 흐름)
6. 프로세스는 독립적 존재여서 영향을 주지 않음 <-> 스레드는 프로그램 자체가 종료
7. 프로세스 > 스레드
8. 스레드의 작업 크기는 스레드 스케줄러에 의해 결정됨

### 정의
1. 스레드 클래스로 직접생성
   ```
       Thread thread = new Thread(Runnable task);
    
    class Task implements Runnable {
    @Override
        public void run() {
            //스레드가 처리할 소스코드
        }
    }

    Runnable task = new Task();
    Thread thread = new Thread(task);
    Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {

        }
    });
   ```

2. 상속받은 자식클래스 생성
   ```
   class ChildThread extends Thread {
        @Override
        public void run() {
            //스레드가 실행할 코드
        }
    }
    Thread thread = new ChildTread();
    thread.start();
   ```

3. 익명클래스
   ```
    Thread t = new Thread() {
        @Override
        public void run() {
            //스레드가 실행할 코드
        }
    }
   ```

### 사용
1. start()
2. 큐 FIFO, 스택FILO

### 스레드명
1. 서브스레드는 특정 이름이 생성되지 않아 setName()으로 정해줌
2. 디버깅 시 현재 어떤 스레드가 실행중인지 확인 가능
3. Thread.currentThread(): 현재 동작중인 스레드에 대한 객체 얻어옴

### 용어
1. 스레드: 프로그램 내 코드의 흐름
2. 멀티스레드: 여러개 스레드 생성해 병렬처리되는 것처럼 만들어줌
3. 논리 코어: 물리 코어 1개를 가상으로 여러개로 만들어서 사용
4. 논리 프로세스(스레드): 스레드 작업 처리 가능한 가상 프로세서
5. 하이퍼 스레딩: 실제로 스레드를 동시에 실행시키는 기능

### 상태
1. start(): RUNNABLE 실행 대기 상태
2. sleep(): PAUSE 상태
3. 스레드 객체 생성 -> 스레드가 작업할 내용을 오버라이드된 run() 안에 구현 -> start() 메소드 호출 -> 실행 대기 상태로 변경 -> 본인 작업 순서가 되면 run() 내용을 한번 실행 -> run() 호출이 종료되면 실행 대기 상태로 변경 -> 다른 스레드가 작업 한 번 실행 -> 다른 스레드가 실행 대기 상태가 되면 생성한 스레드 작업 다시 진행 -> 실행 대기 상태 -> ..... -> run() 작업이 더이상 존재하지 않을 때는 TERMINATED로 변경
4. 일시정지 메소드: sleep(), join(), wait()
5. 실행대기로 변경 메소드: interrupt(), notify(), notifyAll(), yield()

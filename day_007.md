# Day 7
## static
1. 정적이라 프로그램 시작부터 종료까지 메모리에서 삭제되지 않음

## 인스턴스 변수와 메소드
1. 객체 생성시(클래스에 선언된) 사용가능한 변수/메소드
2. 객체가 메모리에 저장되어 삭제 전까지 인스턴스 변수/메소드 사용 가능

## 클래스 변수와 메소드
1. 클래스 변수/메소드는 static 키워드로 선언
2. `접근제어자 static 타입 변수명;` </br>
   `접근제어자 static 리턴타입 메소드명() {}` </br>
3. `클래스원형(클래스명).변수명 / 클래스원형(클래스명).메소드명` </br>

## 제어자의 조합
1. 클래스: `public, default, abstract, final` </br>
2. 메소드: `모든 접근제어자, final, abstract, static` </br>
3. 멤버변수: `모든 접근제어자, final, static` </br>
4. 지역변수: `final` </br>
- 메소드: static과 abstract 동시 선언 불가
- 클래스: abstract와 final 동시 사용 불가
- abstract 메소드: private 사용 불가
- 메소드: private = final(확장불가) 둘 중 하나만 선언

## 상속
1. 코드의 재사용성 향상
2. 부모클래스, 자식(하위)클래스
3. 자식은 부모에 존재하는 멤버변수, 메소드 사용 가능
4. 부모는 공통 속성을, 자식은 부모의 속성/기능+자식만의 속성/기능ㅇㅇ
5. 부모클래스 타입으로 선언된 변수에 자식클래스로 만들어진 객체 담을 수 있음
6. 상속: extends 키워드 `public 자식클래스 extends 부모클래스 { }` </br>

## 오버라이딩
1. 부모클래스의 메소드를 자식클래스에서 재정의
2. 동일 메소드로 여러 기능을 만들 수 있어 다형성 향상

## 다형성
1. 다양한 형태를 가지는 성질
2. 자식>부모: 자식, 부모의 형태를 가지게 됨
3. 부모클래스 변수에 자식클래스 객체를 넣어 다양하게 사용
4. 오버라이딩 통한 기능 다양화
5. 추상화를 통해 형태만 남겨놓음
6. 장점: 유연성, 확장성, 가독성, 재사용성, 유지보수성
7. 단점: 성능하락, 복잡도, 오버라이딩 기능 오류, 가독성(관계 레벨이 깊어질경우)

## super
1. 자식>부모의 멤버변수, 메소드, 생성자 접근/호출 시 super 키워드 사용
2. 부모클래스의 멤버변수 접근방식
   ```
   protect, public: super.변수명
   default
      동일 패키지: super.변수명
      다른 패키지: super.getter/setter
   private: super.getter/setter
   ```
3. 부모클래스 메소드 호출 방식
   ```
   public, protected: super.메소드명();
   default
      동일 패키지: super.메소드명();
      다른 패키지: 호출불가
   private: 부모클래스 메소드 호출불가.
   ```
4. super는 항상 먼저 호출
   
## 추상화
1. 핵심적인 내용(껍데기)만 남겨 객체를 단순화한 것
2. 인터페이스/추상클래스
3. 장점: 코드 이해도, 가독성, 재사용성

## 추상클래스
1. 추상화 작업이 진행된 클래스
2. `abstract class 클래스명 {} ` </br>
3. 추상클래스는 인스턴스화 및 객체를 만들 수 없음

## 추상 메소드
1. 선언부만 정의해놓는것
2. 구현부는 상속받은 자식클래스에서 오버라이딩하여 정의
3. `abstract 리턴타입 메소드명(매개변수);

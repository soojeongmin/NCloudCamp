# Day 9
## 중첩클래스
1. 클래스 내부에 타 클래스를 선언한 것
2. 정적 중첩 클래스
  - 외부클래스의 정적 멤버와 동일 위치
  - 외부클래스 객체 생성하지 않아도 인스턴스 생성 가능
  - 외부클래스의 모든 멤버변수/메소드 접근
    ``` NestedClass.Div div = new NestedClass.Div();
    NestedClass.Div.result;
    div.num3; 
    div.getNum3(); 
3. 인스턴스 중첩 클래스
  - 외부클래스의 인스턴스 멤버와 동일 위치
  - 외부클래스의 객체가 생성된 후 인스턴스 객체 생성 가능
  - 외부클래스 모든 멤버변수/메소드 접근
    ```   NestedClass nc = new NestedClass();
    NestedClass.Mul mul = nc.new Mul();
    mul.num1; mul1.getNum1(); mul.multi();
4. 지역 중첩 클래스
  - 메소드 내부 선언 클래스
  - 외부클래스/메소드의 매개변수/지역변수 접근 가능
  - 외부클래스/메소드 내부 인스턴스를 만들어야 사용 가능
5. 익명 중첩 클래스
  - 인터페이스/추상클래스 구현한 클래스의 인스턴스 생성 시 사용됨
  - 클래스명이 없고 선언과 동시에 인스턴스 생성
  - 외부클래스나 메소드의 매개변수, 로컬변수에 접근 가능
6. 중첩 클래스 장점
  - 동일 파일 내 복수 클래스 정의 가능 -> 코드의 가독성 향상
  - 클래스의 접근성 제한(타 클래스에서 참조 불가능 중첩클래스)
  - 외부 클래스 멤버변수/메소드 접근 가능

## 객체배열
1. 동일 타입 객체를 다수 저장 가능한 배열
   `클래스명[] 배열명 = new 클래스명[배열 크기];`</br>
2. 추상클래스/인터페이스 배열일 경우 상속받은 자식객체가 요소로 대입 가능해 확장성 향상
   `추상클래스명, 인터페이스명[] 배열명 = new 추상클래스명, 인터페이스[배열의 크기];`</br>
3. 초기화가 null로 되기때문에 null체크를 통해 예외처리, 배열의 크기값을 바꿀 수 없어 새로운 배열로 만든다

## 예외처리
1. 예외: 프로그램의 강제 종료를 초래하는 원인
   컴파일에러: 컴파일 중 발생
   런타임에러: 프로그램 실행 중 발생
   논리적에러: 실행은 되나 원하는대로 동작하지 않음
   Checked Exception: 컴파일러가 예외처리 코드 작성을 강제시킴. try~catch 혹은 throws로 예외처리
   Unchecked Exception: 예외처리 코드를 작성하지 않아도 되는 예외
2. try~catch~finally(작성 자유, 무조건실행됨)
3. getMessage(): 예외 클래스 객체에 저장된 메시지 전달
   printStackTrace(): 호출된 메소드/클래스/예외메시지 정보 모두 출력(보안 취약점으로 println, log 대체)
4. 예외 발생: `예외클래스 변수명 = new 예외클래스(메세지); throw 변수명;` </br>
5. 예외 선언: `리턴타입 메소드명(매개변수) throws 예외클래스 { }` </br>
6. 코드의 가독성 증가, 안정적인 프로그램 등의 장점
